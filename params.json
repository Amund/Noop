{"name":"Noop","tagline":"Tiny PHP MVC framework","body":"# NOOP\r\n\r\nNOOP is a *really* tiny PHP framework for small/medium sized PHP project, based on a *really* free [MVC architecture](#mvc). The main idea behind this library is being unopinionated, and therefore staying as close as possible of... PHP. There are no PHP extensions in this library, it's just about organization. You know PHP, you'll use PHP.\r\n\r\n**Installation** : Just copy the folder to your Apache server, and activate `mod_rewrite` module.\r\n\r\nTechnically, NOOP is a **one file** library (\"*noop.php*\"), and a **one object** library (\"*noop*\"). [All methods](#api) in this object are *statics*, and can be classified this way :\r\n\r\nType|Methods\r\n----:|:----\r\nCore | [`config`](#method-config), [`start`](#method-start), [`view`](#method-view) and [`pdo`](#method-pdo)\r\nRegistry / Arrays | [`get`](#method-get), [`set`](#method-set), [`del`](#method-del)\r\nHTTP response | [`output`](#method-output), [`redirect`](#method-redirect), [`status`](#method-status)\r\nHelpers | [`check`](#method-check), [`filter`](#method-filter)\r\nDev tools | [`inspect`](#method-inspect), [`benchmark`](#method-benchmark)\r\n\r\n<a name=\"registry\"></a>\r\n## Registry system [^](#noop)\r\nAll datas in NOOP are stored in a unique multilevel associative array, its registry system. It's globally accessible without polluting global scope, and organized as follow :\r\n- `config` All configuration variables in there\r\n- `app` App related infos, calculated from the request\r\n- `request` Details of the request, and controller related vars\r\n- `controllers` Collection of PHP scripts to include\r\n- `pdo` Collection of PDO instances already created\r\n- `benchmark` Collection of benchmarks\r\n- `var` Your playground, store anything you want...\r\n\r\n\r\nDuring the development, you can inspect this registry at any time with the method [`inspect`](#method-inspect).\r\n    \r\n\t// Inspect all the registry...\r\n\techo noop::inspect();\r\n\r\n    // ...or a part...\r\n\techo noop::inspect( 'config' );\r\n\r\n    // ...or a part of a part...\r\n\techo noop::inspect( 'config/path' );\r\n\t\r\nYou can also manage all these keys with the [`get`](#method-get), [`set`](#method-set) and [`del`](#method-del) methods.\r\n\t\r\n\t// Store a new key...\r\n\tnoop::set( 'var/foo', 'bar' );\r\n\r\n    // ...display it...\r\n\techo noop::get( 'var/foo' );\r\n\r\n    // ...and remove it\r\n\tnoop::del( 'var/foo' );\r\n\r\nBecause it is a simple associative array, you can do any manipulation you want in the registry. But all the root's keys (except `var`) are internally managed, so use them with caution.\r\n\r\n\r\n\r\n<a name=\"mvc\"></a>\r\n## MVC architecture [^](#noop)\r\n\r\n### Models [^](#noop)\r\nThere is no direct support for anything related to models in NOOP. PHP objects are powerful enough !\r\n\r\nHowever, to stay in a NOOP way, you can store your classes in the folder `secure/model`, and declare it with a new configuration variable :\r\n\r\n    noop::set( 'config/path/model', 'secure/model' );\r\n\r\nThen add your favorite PHP autoload, perhaps in `index.php` (at the root folder of NOOP).\r\n\r\nNote : Since v2.0.2, the folder `secure/model` and a generic autoload are added. Simply put your classes in this folder, and you're good to go.\r\n\r\n### Controllers [^](#noop)\r\n\r\nA controller in NOOP is a PHP script file, located in the controller folder.\r\n\r\nThis folder is located in `secure/control` by default, and can be modified in the configuration registry :\r\n\r\n\tnoop::set( 'config/path/controller', 'my/new/path' );\r\n\r\nThe default controller is `secure/control/index.php`, and you can also change this path in the configuration registry :\r\n\r\n    noop::set( 'config/default/controller', 'homepage' );\r\n\r\nOf course, you can override multiple default configurations with :\r\n\r\n    noop::config( array(\r\n        'default'=> array( 'controller'=> 'homepage' ),\r\n\t\t'path'=> array( 'controller'=> 'my/new/path' )\r\n    ) );\r\n\r\nHere's the fun part.\r\n\r\nThe controller is called by an URL, as many other MVC framework. But no routing table around, at least not as usual : the filesystem is the routing table.\r\n\r\n\r\nConsider this controllers folder :\r\n\r\n    /[noop-dir]\r\n\t\t/secure\r\n\t\t\t/control\r\n\t\t\t\t/product\r\n\t\t\t\t\tacme.php\r\n\t\t\t\tindex.php\r\n\t\t\t\tproduct.php\r\n\r\nThen, add this code in `index.php` and `product.php`.\r\n\r\n    <?php\r\n\techo noop::inspect( 'request' ); /// details on how the URL is parsed\r\n\techo noop::inspect( 'controllers' ); /// What files will be included\r\n\r\nFinally, take a breath, and try some URL :\r\n\r\n- `http://[noop-dir]/`<br>\r\nThere is no controller, this will use the default controller, `index`. So, only the file `index.php` will be included.\r\n- `http://[noop-dir]/contact`<br>\r\nThere is no `contact.php` in the controller folder, you'll face a 404 error.\r\n- `http://[noop-dir]/product`<br>\r\nThere is a `product.php` file, it will be included.\r\n- `http://[noop-dir]/product/anvil`<br>\r\n`product.php` is always a file, it will be included. `product/anvil.php` is not, so `anvil` is not a real controller, it will be considered as a trail (a parameter) for the controller `product`.\r\n- `http://[noop-dir]/product/acme`<br>\r\n`product.php` is included, and `acme.php` too.\r\n- `http://[noop-dir]/product/acme/anvil`<br>\r\n`product.php` and `acme.php` are included, and anvil become a trail.\r\n- `http://[noop-dir]/product/acme/anvil/black/iron`<br>\r\nSame as above, but with a long trail. To use this list of parameters in your controller, just [`explode`](http://php.net/explode) it.\r\n\r\n\r\n    $trails = explode( '/', noop::get( 'request/trail' ) );\r\n\t// Array (\r\n    //     [0] => anvil\r\n    //     [1] => black\r\n    //     [2] => iron\r\n    // )\r\n\r\n\r\nIf you've got this, you've done the hardest part of NOOP.\r\n\r\n### Views [^](#noop)\r\n\r\nThere are 2 ways to use NOOP controllers/views. The first is a more traditional PHP way, more readable for NOOP beginners, but more verbose. The second is the pure NOOP way, for real power user.\r\n\r\nLet's start gently.\r\n\r\n####The rusty PHP way\r\n\r\nWe want a page to display a product detail, say... hmm... an anvil. From acme. The URL will be\r\n\r\n`http://[noop-dir]/product?id=123`\r\n\r\nConsider the following controller `secure/controller/product.php`. I let you implement the class `Product`, in the file `secure/model/Product.php` [for example](#models-).\r\n\r\n    <?php\r\n\t\r\n\t// We get the product id from the request\r\n\t$id = $_GET['id'];\r\n\t\r\n\t// Create a product instance\r\n\t$product = new Product();\r\n\t\r\n\t// Load the product with id 123 from database\r\n\t$product->load( $id );\r\n\t\r\n\t// Get all product properties as array( 'id'=>123, 'name'=>'Anvil', 'matter'=>'Iron', 'color'=>'Black' )\r\n\t$product_data = $product->data();\r\n\t\r\n\t// We load the \"product\" view,\r\n\t// inject product data in it,\r\n\t// and store the returned string\r\n\t$product_view = noop::view( 'product', $product_data );\r\n\t\r\n\t// Prepare the final page\r\n\t$data = array();\r\n\t$data['title'] = 'Product details';\r\n\t$data['content'] = $product_view;\r\n\t\r\n\t// We get the \"page\" view,\r\n\t// inject $data in it (with the product view),\r\n\t// and echo it, this time\r\n\techo noop::view( 'page', $data );\r\n\t\r\n\t// Then return output to browser.\r\n\tnoop::output( NULL, 'html' );\r\n\t\r\nYou'll need a product view `secure/view/product.php`, using the $data variable transmitted:\r\n\r\n    <div class=\"product\">\r\n\t\t<label>ID</label> <?=$data['id']?><br>\r\n\t\t<label>Name</label> <?=$data['name']?><br>\r\n\t\t<label>Matter</label> <?=$data['matter']?><br>\r\n\t\t<label>Color</label> <?=$data['color']?><br>\r\n\t</div>\r\n\r\nTo avoid warnings on non-existent keys in $data, we can also use `noop::get` on `$data`, as a filter:\r\n\r\n    <div class=\"product\">\r\n\t\t<label>ID</label> <?=noop::get( 'id', $data )?><br>\r\n\t\t<label>Name</label> <?=noop::get( 'name', $data )?><br>\r\n\t\t<label>Matter</label> <?=noop::get( 'matter', $data )?><br>\r\n\t\t<label>Color</label> <?=noop::get( 'color', $data )?><br>\r\n\t</div>\r\n\r\nAnd we also need a reusable standard page view `secure/view/page.php`:\r\n\r\n    <!DOCTYPE html>\r\n\t<html>\r\n\t<head>\r\n\t\t<title><?=noop::get( 'title', $data )?></title>\r\n\t</head>\r\n\t<body>\r\n\t\r\n\t\t<h1><?=noop::get( 'title', $data )?></h1>\r\n\t\t\r\n\t\t<?=noop::get( 'content', $data )?>\r\n\t\t\r\n\t</body>\r\n\t</html>\r\n\r\n####The shiny NOOP way\r\n\r\nNOOP has a killer feature : its registry ! You know, this fabulous... simple associative array.\r\n\r\nIn this array, there is a special place you are encouraged to store in, it's `var`. It was previously presented as your playground, so let's use it, and save some code. Don't hesitate to add some `noop::inspect( 'var' )` to see its content.\r\n\r\nAnd as we rewrite, we will also use the controller trail instead of querystring. URL will become `http://[noop-dir]/product/123`\r\n\r\n\t\r\n    <?php\r\n\t\r\n\t// Load product\r\n\t$id = noop::get( 'request/trail' );\r\n\t$product = new Product();\r\n\t$product->load( $id );\r\n\t\r\n\t// Store all product properties as an associative array in the NOOP registry\r\n\tnoop::set( 'var/product', $product->data() );\r\n\t\r\n\t// Store the compiled product view in the NOOP registry\r\n\tnoop::set( 'var/product/view', noop::view( 'product' ) );\r\n\t\r\n\t// Set the page title\r\n\tnoop::set( 'var/title', 'Product details' );\r\n\t\r\n\t// Then echo page\r\n\techo noop::view( 'page' );\r\n\t\r\n\t\r\nWe modify the product view, to get data directly from the registry:\r\n\r\n    <div class=\"product\">\r\n\t\t<label>ID</label> <?=noop::get( 'var/product/id' )?><br>\r\n\t\t<label>Type</label> <?=noop::get( 'var/product/type' )?><br>\r\n\t\t<label>Name</label> <?=noop::get( 'var/product/name' )?><br>\r\n\t\t<label>Matter</label> <?=noop::get( 'var/product/matter' )?><br>\r\n\t\t<label>Color</label> <?=noop::get( 'var/product/color' )?><br>\r\n\t</div>\r\n\r\nAnd the page view too:\r\n\r\n    <!DOCTYPE html>\r\n\t<html>\r\n\t<head>\r\n\t\t<title><?=noop::get( 'var/title' )?></title>\r\n\t</head>\r\n\t<body>\r\n\t\r\n\t\t<h1><?=noop::get( 'var/title' )?></h1>\r\n\t\t\r\n\t\t<?=noop::get( 'var/page/content' )?>\r\n\t\t\r\n\t</body>\r\n\t</html>\r\n\r\n####Choose your path\r\nObviously, there is no best way, it's just a matter of taste. You can choose a way, or mix them, or whatever. That's what I call unopinionated.\r\n\r\n\r\n<a name=\"api\"></a>\r\n## API [^](#noop)\r\n\r\n\r\n\r\n<a name=\"method-benchmark\"></a>\r\n### benchmark( `$name`[, `$action`] ) [^](#noop)\r\n\r\nSet/Get some benchmarks, to trap too long functions, etc... during the development. A benchmark with name \"page\" is added internally. All benchmarks are also added as HTTP headers (\"`X-Benchmark-Page: 0.123456`\").\r\n\r\n###### Parameters\r\n- `$name` Required, String. Name of the benchmark.\r\n- `$action` Optional, Boolean or NULL, default to NULL. TRUE start the benchmark, FALSE stop it, and NULL (or no value) return the timer.\r\n\r\n###### Return\r\n- If `$action` is NULL, return the benchmark value, in seconds.\r\n\r\n###### Example\r\n    noop::benchmark( 'mylongloop', TRUE ); // start\r\n    //...some code to evaluate...\r\n    noop::benchmark( 'mylongloop', FALSE ); // stop\r\n\r\n    // ...then print\r\n    echo noop::benchmark( 'mylongloop' ); // '0.123456', in seconds\r\n    \r\n    // Additionally, you'll find a \"X-Benchmark-mylongloop: 0.123456\" in HTTP response headers\r\n\r\n\r\n\r\n<a name=\"method-check\"></a>\r\n### check( `$reg`, `$var` ) [^](#noop)\r\n\r\nCheck if $var match the regexp $reg.\r\n\r\n###### Parameters\r\n- `$reg` Required, String or Array\r\n- `$var` Required, String or Array\r\n\r\n###### Return\r\n- Boolean, if `$reg` and `$var` are strings\r\n- Array of errors, if `$reg` and `$var` are arrays\r\n\r\n###### Example\r\nSimple version, with strings\r\n\r\n    $test = noop::check( '#\\d+#', '123' );\r\n    var_dump( $test ); // => TRUE\r\n\r\n    $test = noop::check( '#\\d+#', 'my test' );\r\n    var_dump( $test ); // => FALSE\r\n\r\nLess simple version, with arrays\r\n\r\n    $reg = array( 'a'=>'#\\d+#', 'b'=>'#\\w{1,}#' );\r\n    $var = array( 'a'=>'123', 'b'=>'is checked', 'c'=>'is not checked' )\r\n    $errors = noop::check( $reg, $var );\r\n    var_dump( $test ); // => array()\r\n\r\n    $reg = array( 'a'=>'#\\d+#', 'b'=>'#\\w{1,}#' );\r\n    $var = array( 'a'=>'wrong', 'b'=>'right', 'c'=>'is not checked' )\r\n    $errors = noop::check( $reg, $var );\r\n    var_dump( $test ); // => array( 'a'=>FALSE )\r\n\r\n\r\n\t\r\n<a name=\"method-config\"></a>\r\n### config( `$config` ) [^](#noop)\r\n\r\nExtend/Override NOOP configuration registry. You can load different parts of a heavy configuration, configure pathes, manage DB connections, add mime types, switch configuration (dev/prod), add your own app specific configuration variables, etc...\r\n\r\n###### Parameters\r\n- `$config` Required, Array\r\n\r\n###### Example\r\n    var_dump( noop::get( 'config' ) );\r\n    \r\n    // Array (\r\n    //     [default] => Array (\r\n    //         [controller] => index\r\n    //         [lang] => en\r\n    //         [mime] => html\r\n    //     )\r\n    // ...\r\n    \r\n    $config = array(\r\n        'default'=>array(\r\n            'controller'=>'default',\r\n            'lang'=>'fr'\r\n        )\r\n    );\r\n    noop::config( $config );\r\n    \r\n    var_dump( noop::get( 'config' ) );\r\n    \r\n    // Array (\r\n    //     [default] => Array (\r\n    //         [controller] => default\r\n    //         [lang] => fr\r\n    //         [mime] => html\r\n    //     )\r\n    // ...\r\n\r\n\r\n\r\n<a name=\"method-del\"></a>\r\n### del( `$path`[, `$array`] ) [^](#noop)\r\nDelete a key in an array, based on a virtual `path` to this key.\r\n\r\n###### Parameters\r\n- `$path` Required, String.\r\n- `$array` Optional, Array. If omitted, the NOOP registry is used.\r\n\r\n###### Return\r\n- FALSE if `$path` was empty\r\n- NULL if the key was not found in array\r\n- Otherwise, the deleted value is returned\r\n\r\n###### Example\r\n    $myarr = array(\r\n        'path'=>array(\r\n            'to'=>array(\r\n                'key'=>'value'\r\n            )\r\n        )\r\n    );\r\n    \r\n    noop::del( 'path/to/key', $myarr );\r\n\r\n    // Array (\r\n    //     [path] => Array (\r\n    //         [to] => Array\r\n    //             (\r\n    //             )\r\n    //     )\r\n    // )\r\n\r\n\r\n<a name=\"method-filter\"></a>\r\n### filter( `$src`, `$allowed` ) [^](#noop)\r\nPerform a filter on an array with a whitelist of keys. Other keys are removed.\r\n\r\n###### Parameters\r\n- `$src` Required, Array. The source array\r\n- `$allowed` Required, Array. The whitelist of keys\r\n\r\n###### Return\r\n- A new array, with only withelisted keys\r\n\r\n###### Example\r\n    // http://test/?q=42&lang=fr&out=txt&referer=\r\n    $request = noop::filter( $_GET, array( 'q', 'lang' ) );\r\n    \r\n    // Array (\r\n    //     [q] => 42\r\n    //     [lang] => fr\r\n    // )\r\n\r\n\r\n\r\n<a name=\"method-get\"></a>\r\n### get( `$path`[, `$array`] ) [^](#noop)\r\nGet a value from an array, based on a virtual `$path` to its key.\r\n\r\n###### Parameters\r\n- `$path` Required, String.\r\n- `$array` Optional, Array. If omitted, the NOOP registry is used.\r\n\r\n###### Return\r\n- `$array`, if the path is empty (`''`) or root (`'/'`)\r\n- The key value, if the `$path` is found\r\n- Otherwise, `NULL`\r\n\r\n###### Example\r\n    $myarr = array(\r\n        'path'=>array(\r\n            'to'=>array(\r\n                'key'=>'value'\r\n            )\r\n        )\r\n    );\r\n    \r\n    echo noop::get( 'path/to/key', $myarr ); // => 'value'\r\n\r\n\r\n\r\n<a name=\"method-inspect\"></a>\r\n### inspect( [`$path`[, `$arr`]] ) [^](#noop)\r\nDevelopment tool to inspect variable in a readable way.\r\n\r\n###### Parameters\r\n- `$path` Optional, String. The \"virtual\" path to the key. Default to `''`\r\n- `$arr` Optional, Array. If omitted, the NOOP registry is used.\r\n\r\n###### Return\r\n- Print formatted string representation of the variable if `$return` is TRUE\r\n\r\n###### Example\r\n    // To have a look on current request\r\n    echo noop::inspect( 'request' );\r\n\r\n\r\n<a name=\"method-output\"></a>\r\n### output( [`$content`[, `$type`]] ) [^](#noop)\r\nStop the current script, and send the HTTP response to the client.\r\n\r\n###### Parameters\r\n- `$content` Optional, String. The response body to send\r\n- `$type` Optional, String. A valid MIME type, or a shortcut (`'text'`, `'html'` or `'json'`)\r\n\r\n\r\n\r\n<a name=\"method-pdo\"></a>\r\n### pdo( `$name` ) [^](#noop)\r\nCreate a named PDO object, based on its configuration. The object is cached at the first call, for further use.\r\n\r\nIn the `config` registry, there is a dedicated `pdo` array to store your collection of connection strings. These string are constructed in the form `'[driver],[dsn],[user],[password]'`\r\n\r\nExample: `'mysql,host=localhost;dbname=db,admin,fZ5GdsV4'`\r\n\r\n###### Parameters\r\n- `$name` Required, String\r\n\r\n###### Return\r\n- [PDO instance](http://php.net/pdo)\r\n\r\n###### Example\r\nSetup databases connections\r\n\r\n    noop::config( array(\r\n        'pdo'=>array(\r\n            'db1'=>'mysql,host=localhost;dbname=db1,user1,password1',\r\n            'db2'=>'mysql,host=localhost;dbname=db2,user2,password2',\r\n        )\r\n    ) );\r\n\r\nThen use them anywhere\r\n\r\n    $stmt = noop::pdo( 'db1' )->query( 'SELECT * FROM table' );\r\n\r\n\r\n<a name=\"method-redirect\"></a>\r\n### redirect( `$url`[, `$code`] ) [^](#noop)\r\nStop the current script, and make an HTTP redirect to `url`.\r\n\r\n###### Parameters\r\n- `$url` Required, String. The URL to redirect to\r\n- `$code` Optional, Integer. The HTTP redirect code. Default to `'302'`\r\n\r\n###### Example\r\n    // An external URL\r\n\tnoop::redirect( 'http://www.google.com/' );\r\n\t\r\n\t// or a relative URL\r\n\tnoop::redirect( noop::get( 'app-url' ).'/contact' );\r\n\r\n\r\n<a name=\"method-set\"></a>\r\n### set( `$path`, `$value`[, `$array`] ) [^](#noop)\r\nSet a value from an array, based on a virtual `$path` to its key.\r\n\r\n###### Parameters\r\n- `$path` Required, String.\r\n- `$value` Required, Mixed.\r\n- `$array` Optional, Array. If omitted, the NOOP registry is used.\r\n\r\n###### Return\r\n- `TRUE`\r\n\r\n###### Example\r\n    $arr = array();\r\n    noop::set( 'first', 'foo', $arr );\r\n    noop::set( 'second/key', array( 1, 2, 3 ), $arr );\r\n    \r\n    // Array (\r\n    //     [first] => foo\r\n    //     [second] => Array (\r\n    //         [key] => Array (\r\n    //             [0] => 1\r\n    //             [1] => 2\r\n    //             [2] => 3\r\n    //         )\r\n    //     )\r\n    // )\r\n\r\n\r\n\r\n<a name=\"method-start\"></a>\r\n### start() [^](#noop)\r\nLaunch NOOP app with the current configuration. In the registry, `app`, `request` and `controllers` arrays are populated, and the controllers scripts are included.\r\n\r\nAll configuration variables must be modified **before** this method.\r\n\r\nAfter controllers inclusion, there is an implicit call to `noop::output()`.\r\n\r\n\r\n\r\n<a name=\"method-status\"></a>\r\n### status( `$code`, `$status`[, `$content`[, `$type`]] ) [^](#noop)\r\nStop the current script, and return HTTP response to the client.\r\n\r\n###### Parameters\r\n- `$code` Required, Integer. HTTP response code\r\n- `$status` Required , String. HTTP response status\r\n- `$content` Optional, String. Body of the response. Default `''`\r\n- `$type` Optional, String. A MIME type, or a shortcut. Default `'html'`\r\n\r\n\r\n\r\n<a name=\"method-view\"></a>\r\n### view( `$name`[, `$data`] ) [^](#noop)\r\nCompile the `$name` view.\r\n\r\n###### Parameters\r\n- `$name` Required, String. The relative path to the view file, minus \".php\"\r\n- `$data` Optional, Array. An additional data array to transmit to the view.\r\n\r\n###### Return\r\n- String. The compiled view (where variables are replaced with values)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}